import json
from typing import cast

import pulumi
import pulumi_aws as aws

# This stuff is being encapsulated in navigator-infra and we should use that once it is ready
# IAM role trusted by App Runner
data_in_pipeline_role = aws.iam.Role(
    "data-in-pipeline-role",
    assume_role_policy=aws.iam.get_policy_document(
        statements=[
            aws.iam.GetPolicyDocumentStatementArgs(
                effect="Allow",
                principals=[
                    aws.iam.GetPolicyDocumentStatementPrincipalArgs(
                        type="Service",
                        identifiers=["build.apprunner.amazonaws.com"],
                    )
                ],
                actions=["sts:AssumeRole"],
            )
        ]
    ).json,
)

# Attach ECR access policy to the role
data_in_pipeline_role_policy = aws.iam.RolePolicy(
    "data-in-pipeline-role-ecr-policy",
    role=data_in_pipeline_role.id,
    policy=aws.iam.get_policy_document(
        statements=[
            aws.iam.GetPolicyDocumentStatementArgs(
                effect="Allow",
                actions=[
                    "ecr:GetDownloadUrlForLayer",
                    "ecr:BatchGetImage",
                    "ecr:DescribeImages",
                    "ecr:GetAuthorizationToken",
                    "ecr:BatchCheckLayerAvailability",
                ],
                resources=["*"],
            )
        ]
    ).json,
)

data_in_pipeline_ecr_repository = aws.ecr.Repository(
    "data-in-pipeline-ecr-repository",
    encryption_configurations=[
        aws.ecr.RepositoryEncryptionConfigurationArgs(
            encryption_type="AES256",
        )
    ],
    image_scanning_configuration=aws.ecr.RepositoryImageScanningConfigurationArgs(
        scan_on_push=False,
    ),
    image_tag_mutability="MUTABLE",
    name="data-in-pipeline",
    opts=pulumi.ResourceOptions(protect=True),
)


# Export the name of the bucket
pulumi.export("ecr_repository_url", data_in_pipeline_ecr_repository.repository_url)


#######################################################################
# Create the Aurora service for the Document Store.
#######################################################################
environment = pulumi.get_stack()

config = pulumi.Config()
username = config.require("db_user")

name = pulumi.get_project()

tags = {
    "CPR-Created-By": "pulumi",
    "CPR-Pulumi-Stack-Name": pulumi.get_stack(),
    "CPR-Pulumi-Project-Name": pulumi.get_project(),
    "CPR-Tag": f"{environment}-{name}-store",
    "Environment": environment,
}

vpc_per_env = {"staging": "staging-vpc", "production": "NavigatorProd-vpc"}

vpc = aws.ec2.get_vpc_output(
    tags={
        "Name": vpc_per_env[environment],
    }
)

aurora_security_group = aws.ec2.SecurityGroup(
    f"{name}-aurora-sg",
    vpc_id=vpc.id,
    description=f"Security group for {name} Aurora DB",
    ingress=[
        aws.ec2.SecurityGroupIngressArgs(
            description="Allow PostgreSQL access",
            protocol="tcp",
            from_port=5432,
            to_port=5432,
            security_groups=[],  # TODO
        )
    ],
    egress=[
        aws.ec2.SecurityGroupEgressArgs(
            from_port=0,
            to_port=0,
            protocol="-1",
            cidr_blocks=["0.0.0.0/0"],
        ),
    ],
    tags=tags,
)


secret = aws.secretsmanager.Secret(
    f"{name}-aurora-credentials",
    description=f"Credentials for {name} cluster",
)

# Create the secret value with username + autogenerated password.
secret_value = aws.secretsmanager.SecretVersion(
    f"{name}-aurora-credentials-value",
    secret_id=secret.id,
    secret_string=pulumi.Output.secret(
        json.dumps(
            {
                "username": username,
                "password": aws.secretsmanager.get_random_password(
                    password_length=20,
                    exclude_punctuation=True,
                ).random_password,
            }
        )
    ),
)

# Extract values from the JSON secret to use in the Aurora cluster
credentials = secret_value.secret_string.apply(lambda s: json.loads(cast(str, s)))

# Look up the private subnets in the selected VPC.
# Resolve the VPC ID inside an apply so the underlying AWS call
# receives a plain string.
private_subnets = vpc.id.apply(
    lambda vpc_id: aws.ec2.get_subnets(
        filters=[
            aws.ec2.GetSubnetsFilterArgs(
                name="vpc-id",
                values=[vpc_id],
            ),
            aws.ec2.GetSubnetsFilterArgs(
                name="tag:Name",
                values=["*private*"],
            ),
        ]
    )
)

aurora_subnet_group = aws.rds.SubnetGroup(
    f"{name}-aurora-subnet-group",
    subnet_ids=private_subnets.apply(lambda result: result.ids),
    tags=tags,
)


aurora_cluster = aws.rds.Cluster(
    f"{name}-aurora-cluster",
    engine="aurora-postgresql",
    engine_version="18.1",
    master_username=credentials.apply(lambda creds: creds["username"]),
    master_password=credentials.apply(lambda creds: creds["password"]),
    db_subnet_group_name=aurora_subnet_group.name,
    vpc_security_group_ids=[aurora_security_group.id],
    backup_retention_period=7,  # Retention is included in Aurora pricing for up to 7 days. Longer retention would add charges.
    preferred_backup_window="02:00-03:00",
    preferred_maintenance_window="sun:04:00-sun:05:00",
    deletion_protection=True,
    serverlessv2_scaling_configuration=aws.rds.ClusterServerlessv2ScalingConfigurationArgs(
        min_capacity=0,
        max_capacity=2,
    ),
    tags=tags,
)

aurora_instances = [
    aws.rds.ClusterInstance(
        f"{name}-aurora-instance-{i}",
        cluster_identifier=aurora_cluster.id,
        instance_class="db.serverless",
        engine=aurora_cluster.engine,
        publicly_accessible=False,
        auto_minor_version_upgrade=True,
        tags=tags,
    )
    for i in range(2)
]


pulumi.export(f"{name}-aurora-cluster-name", aurora_cluster._name)
pulumi.export(
    f"{name}-aurora-instance-ids",
    [instance.id for instance in aurora_instances],
)
pulumi.export(f"{name}-aurora-endpoint", aurora_cluster.endpoint)
pulumi.export(f"{name}-aurora-reader-endpoint", aurora_cluster.reader_endpoint)
pulumi.export(f"{name}-aurora-secret-arn", secret.arn)
