import abc
from dataclasses import fields
from pydantic.dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, ClassVar, Sequence
from pydantic import ConfigDict


@dataclass(config=ConfigDict(frozen=True, validate_assignment=True, extra="forbid"))
class BaseIngestRow(abc.ABC):
    """Represents a single row of input from a CSV."""

    row_number: int

    VALID_COLUMNS: ClassVar[set[str]] = set()

    @classmethod
    def from_row(cls, row_number: int, data: dict[str, str]):
        """Parse a row from a CSV."""
        field_info = cls.field_info()
        return cls(
            row_number=row_number,
            **{
                cls._key(k): cls._parse_str(cls._key(k), v, field_info)
                for (k, v) in data.items()
                if cls._key(k) in field_info.keys()
            },
        )

    @classmethod
    def field_info(cls) -> dict[str, type]:
        """Returns an information mapping from field name to expected type."""
        return {field.name: field.type for field in fields(cls)}

    @classmethod
    def _parse_str(cls, key: str, value: str, field_info: dict[str, type]) -> Any:
        if key not in field_info:
            # Let pydantic deal with unexpected fields
            return value

        if field_info[key] == datetime:
            if "T" in value:
                # this doesn't accept all valid ISO 8601 strings, only ones
                # generated by isoformat. So we need some shenanigans.
                value_to_use = value.replace("Z", "+00:00")
                return datetime.fromisoformat(value_to_use)
            else:
                return datetime.strptime(value, "%Y-%m-%d").replace(tzinfo=timezone.utc)

        if field_info[key] == list[str]:
            return [e.strip() for e in value.split(";") if e.strip()]

        if field_info[key] == int:
            return int(value) if value else 0

        if field_info[key] == str:
            if (na := str(value).lower()) == "n/a":
                return na
            else:
                return value

        # Let pydantic deal with other field types (e.g. str-Enums)
        return value

    @staticmethod
    def _key(key: str) -> str:
        return key.lower().replace(" ", "_")


def validate_csv_columns(
    column_names: Sequence[str],
    valid_column_names: set[str],
) -> list[str]:
    """Check that the given set of column names is valid."""

    def original_name(col: str) -> str:
        for name in valid_column_names:
            if name.upper() == col:
                return name
        raise ValueError(f"Original name called with value not in set: {col}")

    cols_to_check = set(name.upper() for name in column_names)
    expected = set([name.upper() for name in valid_column_names])
    missing_insensitive = list(expected.difference(cols_to_check))
    missing = [original_name(col) for col in missing_insensitive]
    missing.sort()
    return missing
