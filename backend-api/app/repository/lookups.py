import logging
from typing import Optional, Sequence, cast

from db_client.models.dfce import Geography, Variant
from db_client.models.dfce.family import FamilyDocument, Slug
from db_client.models.document.physical_document import Language
from sqlalchemy import select
from sqlalchemy.exc import MultipleResultsFound
from sqlalchemy.orm import Session

from app.clients.api.geographies import fetch_all_countries
from app.models.config import ApplicationConfig
from app.service.config import get_corpus_type_config_for_allowed_corpora
from app.service.pipeline import IMPORT_ID_MATCHER
from app.service.util import tree_table_to_json

_LOGGER = logging.getLogger(__name__)


def get_config(db: Session, allowed_corpora: list[str]) -> ApplicationConfig:
    return ApplicationConfig(
        geographies=tree_table_to_json(table=Geography, db=db),
        languages={
            lang.language_code: lang.name
            for lang in db.execute(select(Language)).scalars().all()
        },
        document_variants=[
            variant.variant_name
            for variant in db.execute(select(Variant).order_by(Variant.variant_name))
            .scalars()
            .all()
        ],
        corpus_types=get_corpus_type_config_for_allowed_corpora(db, allowed_corpora),
    )


def get_countries_for_region(db: Session, region_slug: str) -> Sequence[Geography]:
    stmt = select(Geography).where(Geography.slug == region_slug)
    geography = db.execute(stmt).scalar_one_or_none()
    if geography is None:
        return []

    is_valid_region = geography.parent_id is None
    if not is_valid_region:  # either unknown or not a region
        return []

    cast(Geography, geography)

    stmt = select(Geography).where(Geography.parent_id == geography.id)
    return db.execute(stmt).scalars().all()


def get_countries_for_slugs(
    db: Session,
    country_slugs: Sequence[str],
) -> Sequence[Geography]:
    stmt = select(Geography).where(Geography.slug.in_(country_slugs))
    geographies = db.execute(stmt).scalars().all()

    # TODO: improve validity checking when we go beyond countries
    return [geo for geo in geographies if geo.parent_id is not None]


def get_countries_by_iso_codes(
    db: Session,
    country_iso_codes: Sequence[str],
):  # TODO: auto generate type @related AUTOGENERATED_GEO_TYPES
    """
    Retrieve countries by their ISO alpha-3 codes.

    :param Session db: Database session.
    :param Sequence[str] country_iso_codes: Sequence of ISO alpha-3 country codes.
    :return Sequence[Geography]: Sequence of Geography objects for valid countries.
    """
    all_countries = fetch_all_countries()
    country_codes = set(code.upper() for code in country_iso_codes)
    return [
        country
        for country in all_countries
        if country["alpha_3"].upper() in country_codes
    ]


def validate_subdivision_iso_codes(db: Session, geography_identifiers: Sequence[str]):
    """
    Validates subdivision ISO codes against the database.

    Retrieves subdivisions from the database using the provided ISO codes.
    Only returns subdivisions (geographies with parent_id).

    :param Session db: Database session.
    :param Sequence[str] geography_identifiers: Sequence of subdivision ISO codes.
    :return list[str]: List of valid subdivision ISO codes.
    """
    if not geography_identifiers:
        return []

    stmt = select(Geography).where(
        Geography.value.in_(list(geography_identifiers)),
        Geography.parent_id.is_not(None),
    )
    slug_geographies = db.execute(stmt).scalars().all()

    return [geo.value for geo in slug_geographies]


def get_geographies_as_iso_codes_with_fallback(
    db: Session,
    geography_identifiers: Sequence[str],
) -> list[str]:
    """Temp function to handle mixed lists of ISO codes and slugs.

    Retrieve geographies by trying ISO codes first, then falling back to slugs.
    Handles mixed lists of ISO codes and slugs.

    :param Session db: Database session.
    :param Sequence[str] geography_identifiers: Sequence of geography identifiers
        (could be ISO codes or slugs).
    :return list[str]: List of ISO codes for valid countries.
    """
    if not geography_identifiers:
        return []

    # First: try to find by ISO codes using new geographies API
    all_countries = fetch_all_countries()
    country_codes = set(code.upper() for code in geography_identifiers)
    geographies = [
        country
        for country in all_countries
        if country["alpha_3"].upper() in country_codes
    ]
    if geographies:
        # Found some by ISO codes
        return [geo["alpha_3"] for geo in geographies]

    # Fallback: try to find by slugs using DB
    stmt = select(Geography).where(Geography.slug.in_(list(geography_identifiers)))
    slug_geographies = db.execute(stmt).scalars().all()
    return [geo.value for geo in slug_geographies if geo.parent_id is not None]


def get_country_by_slug(db: Session, country_slug: str) -> Optional[Geography]:
    stmt = select(Geography).where(Geography.slug == country_slug)
    geography = db.execute(stmt).scalar_one_or_none()

    if geography is None:
        return None

    # TODO: improve when we go beyond countries
    is_valid_country = geography.parent_id is not None
    if not is_valid_country:
        return None

    return geography


def get_parent_iso_codes_from_subdivisions(
    db: Session, iso_codes: Sequence[str]
) -> set[str]:
    """
    Retrieve parent iso codes for given subdivision ISO codes.

    :param Session db: Database session.
    :param Sequence[str] iso_codes: Sequence of subdivision ISO codes.
    :return set[str]: set of parent iso_codes for valid subdivisions.

    """
    if not iso_codes:
        return set()

    parent_ids_subquery = (
        select(Geography.parent_id)
        .where(Geography.value.in_(list(iso_codes)))
        .where(Geography.parent_id.is_not(None))
        .subquery()
    )

    stmt = select(Geography.value).where(
        Geography.id.in_(select(parent_ids_subquery.c.parent_id))
    )
    parent_iso_codes = db.execute(stmt).all()

    return {str(code[0]) for code in parent_iso_codes}


def get_country_slug_from_country_code(db: Session, country_code: str) -> Optional[str]:
    try:
        stmt = select(Geography).where(Geography.value == country_code)
        geography = db.execute(stmt).scalar_one_or_none()
    except MultipleResultsFound:
        _LOGGER.exception(
            "Multiple geographies with country code '%s' found.", country_code
        )
        return None

    if geography is None:
        return None

    geography_slug = geography.slug
    return geography_slug


def is_country_code(db: Session, country_code: str) -> bool:
    EXPECTED_GEO_CODE_LENGTH = 3
    if len(country_code) != EXPECTED_GEO_CODE_LENGTH:
        return False

    try:
        stmt = select(Geography).where(Geography.value == country_code)
        geography = db.execute(stmt).scalar_one_or_none()
    except MultipleResultsFound:
        _LOGGER.exception(
            "Multiple geographies with country code '%s' found.", country_code
        )
        return False

    return bool(geography is not None)


def get_family_document_by_import_id_or_slug(
    db: Session, import_id_or_slug: str
) -> Optional[FamilyDocument]:
    is_import_id = IMPORT_ID_MATCHER.match(import_id_or_slug) is not None
    if is_import_id:
        stmt = select(FamilyDocument).where(
            FamilyDocument.import_id == import_id_or_slug
        )
        family_document = db.execute(stmt).unique().scalar_one_or_none()
    else:
        stmt = (
            select(FamilyDocument)
            .join(Slug, Slug.family_document_import_id == FamilyDocument.import_id)
            .where(Slug.name == import_id_or_slug)
        )
        family_document = db.execute(stmt).unique().scalar_one_or_none()
    return family_document


def doc_type_from_family_document_metadata(family_document: FamilyDocument) -> str:
    """Retrieves the document type from FamilyDocument metadata

    If the field is missing, empty or None, returns an empty string
    Will also return at empty string if the first value of metadata is None
    """
    doctype: list = family_document.valid_metadata.get("type")
    if not doctype or len(doctype) == 0:
        return ""
    return cast(str, doctype[0] or "")
